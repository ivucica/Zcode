/*
   Project: Zcode

   Copyright (C) 2010 Ivan Vucica

   Author: Ivan Vucica,,,

   Created: 2010-12-05 22:36:24 +0100 by ivucica

   This application is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public
   License as published by the Free Software Foundation; either
   version 2 of the License, or (at your option) any later version.

   This application is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Library General Public License for more details.

   You should have received a copy of the GNU General Public
   License along with this library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111 USA.
*/

#import "ProjectDocument.h"
#import "GAFContainer.h"
#import "PBXProject.h"
#import "NSDictionary+SmartUnpack.h"

@implementation ProjectDocument

@synthesize groupsAndFilesView;

#pragma mark -
#pragma mark Init and deinit

- (id)init
{
  if((self=[super init]))
  {
    gafContainers = [[NSArray alloc] initWithObjects:[[GAFContainer alloc] initWithTitle:@"Files"],
                                                     nil];
    pbxProject = [[PBXProject alloc] init];

  }
  return self;
}

- (void)windowControllerDidLoadNib:(NSWindowController *) aController
{
  toolbar = [[NSToolbar alloc] initWithIdentifier:@"toolbar"]; // FIXME toolbar must be inited only once.
  NSWindow* w = [self windowForSheet]; // FIXME is the right way to get NSWindow for this NSDocument?
  //[toolbar insertItemWithItemIdentifier:@"tb_build" atIndex:[[toolbar items] count]];
  [toolbar setDelegate:self];
  [w setToolbar:toolbar];
  //[window toggleToolbarShown:self];
  [toolbar setVisible:YES];
}


// an NSDocument must specify which nib file it uses
-(NSString*)windowNibName
{
  return @"ProjectDocument";
}

-(void)dealloc
{
  [toolbar release];
  for(id container in gafContainers)
  {
    [container release];
  }
  [gafContainers release];
  NSLog(@"Pbxp retaincount: %d", [pbxProject retainCount]);
  [pbxProject release];
  [super dealloc];
}

#pragma mark -
#pragma mark Loading and saving


-(BOOL)readFromURL:(NSURL*)url ofType:(NSString*)type error:(NSError**)error
{
  NSString *path = [url path];
  NSString *pbxProjPath = [path stringByAppendingPathComponent:@"project.pbxproj"];

/*
// This doesnt work on GNUstep.
// TODO check why

  NSDictionary *dict = [NSKeyedUnarchiver unarchiveObjectWithFile:pbxProjPath];
  NSLog(@"Dict %@ from file %@", dict, pbxProjPath);
  
          NSData *data = [NSData dataWithContentsOfFile:pbxProjPath];
        NSKeyedUnarchiver *kua;
        @try {
                kua = [[NSKeyedUnarchiver alloc] initForReadingWithData:data];
        }
        @catch (NSException * e) {
                return NO;
        }
        @finally {
                
        }
        if(!kua)
                return NO;
        
        id obj = [kua decodeObject];
        
        NSLog(@"obj: %@", obj);
  */    
    
  NSString* errstr = nil;
  NSData *data = [NSData dataWithContentsOfFile:pbxProjPath];

  id plist = [NSPropertyListSerialization propertyListFromData:data mutabilityOption:0 format:0 errorDescription:&errstr];

  if(!plist)
  {
    if(error)
    {
      //errstr = [NSString stringWithFormat:@"PBXProj parse fiailed: %@", errstr];
      *error = [NSError errorWithDomain:NSOSStatusErrorDomain 
                                   code:0 // FIXME use correct key
                               userInfo:[NSDictionary dictionaryWithObjectsAndKeys:errstr, NSLocalizedDescriptionKey,
                                                                                   pbxProjPath, NSFilePathErrorKey,
                                                                                   @"Check that project's project.pbxproj exists, that it is not corrupted, and that it is generated by a supported version of Zcode and Xcode.", NSLocalizedRecoverySuggestionErrorKey,
                                                                                   nil]];
    }
    return NO;
  }
  
  //////////////////////
  NSInteger archiveVersion = [[plist objectForKey:@"archiveVersion"] intValue];
  if(archiveVersion != 1)
  {
    if(error)
    {
      *error = [NSError errorWithDomain:NSOSStatusErrorDomain
                                   code:0 // FIXME use correct key
                               userInfo:[NSDictionary dictionaryWithObjectsAndKeys:[NSString stringWithFormat:@"Unsupported archive version: %d", archiveVersion], NSLocalizedDescriptionKey,
                                                                                   pbxProjPath, NSFilePathErrorKey,
                                                                                   @"Check that project's project.pbxproj is generated by a supported version of Zcode and Xcode.", NSLocalizedRecoverySuggestionErrorKey,
                                                                                   nil]];
    }
    return NO;
  }
  
  ////////////////////////
  NSInteger objectVersion = [[plist objectForKey:@"objectVersion"] intValue];
  if(objectVersion != 45)
  {
    NSLog(@"Zcode is only verified to load pbxproj plists of objectVersion 45; currently loading %d", objectVersion);
  }
  
  /////////////////////////
  NSDictionary* objects = [plist objectForKey:@"objects"];
  errstr = nil;
  if(!objects)
    errstr = @"'objects' is nil";
  else if (![objects isKindOfClass:[NSDictionary class]])
    errstr = @"'objects' is not a dictionary";
  if(errstr)
  {
    if(error)
    {
      *error = [NSError errorWithDomain:NSOSStatusErrorDomain
                                   code:0 // FIXME use correct key
                               userInfo:[NSDictionary dictionaryWithObjectsAndKeys:errstr, NSLocalizedDescriptionKey,
                                                                                   pbxProjPath, NSFilePathErrorKey,
                                                                                   @"Check that project's project.pbxproj is generated by a supported version of Zcode and Xcode.", NSLocalizedRecoverySuggestionErrorKey,
                                                                                   nil]];
    }
    return NO;
  }
  
  ///////////////////
  NSString* rootObject = [plist objectForKey:@"rootObject"];
  errstr = nil;
  if(!rootObject)
    errstr = @"'rootObject' specifier is nil";
  else if (![rootObject isKindOfClass:[NSString class]])
    errstr = @"'rootObject' specifier is not a string";
  if(errstr)
  {
    if(error)
    {
      *error = [NSError errorWithDomain:NSOSStatusErrorDomain
                                   code:0 // FIXME use correct key
                               userInfo:[NSDictionary dictionaryWithObjectsAndKeys:errstr, NSLocalizedDescriptionKey,
                                                                                   pbxProjPath, NSFilePathErrorKey,
                                                                                   @"Check that project's project.pbxproj is generated by a supported version of Zcode and Xcode.", NSLocalizedRecoverySuggestionErrorKey,
                                                                                   nil]];
    }
    return NO;
  }  
  
  //////////////////////////
  if(pbxProject)
    [pbxProject release];
  pbxProject = [self newObjectSpecifiedByISAWithPBXDictionary:objects withKey:rootObject required:YES error:error];
  if(! pbxProject)
  {
    if(error && *error)
      return NO; // return immediately, dont overwrite error string since it probably contains more useful info already
    else
      errstr = @"Root object is nil";
  }
  else if (![pbxProject isKindOfClass:[PBXProject class]])
    errstr = @"Root object is not a PBXProject";
  if(errstr)
  {
    if(error)
    {
      *error = [NSError errorWithDomain:NSOSStatusErrorDomain
                                   code:0 // FIXME use correct key
                               userInfo:[NSDictionary dictionaryWithObjectsAndKeys:errstr, NSLocalizedDescriptionKey,
                                                                                   pbxProjPath, NSFilePathErrorKey,
                                                                                   @"Check that project's project.pbxproj is generated by a supported version of Zcode and Xcode.", NSLocalizedRecoverySuggestionErrorKey,
                                                                                   nil]];
    }
    return NO;
  }
    
  
  [gafContainers release];
  gafContainers = [[NSArray alloc] initWithObjects:[pbxProject.mainGroup retain], nil];
  return YES;
}

-(id)newObjectSpecifiedByISAWithPBXDictionary:(NSDictionary*)objects withKey:(NSString*)key required:(BOOL)required error:(NSError**)error
{
  NSString *filename = [self fileName];
  NSDictionary *dict = [objects objectForKey:key];
  NSString *errstr = nil;

  if(!dict)
    errstr = [NSString stringWithFormat:@"'%@' dict is nil", key];
  else if (![dict isKindOfClass:[NSDictionary class]])
    errstr = [NSString stringWithFormat:@"'%@' is not a dictionary", key];
      
  if(errstr)
  {
    NSLog(@"%@", errstr);
    if(error  && required)
    {
      *error = [NSError errorWithDomain:NSOSStatusErrorDomain
                                   code:0 // FIXME use correct key
                               userInfo:[NSDictionary dictionaryWithObjectsAndKeys:errstr, NSLocalizedDescriptionKey,
                                                                                   filename, NSFilePathErrorKey,
                                                                                   @"Check that project's project.pbxproj is generated by a supported version of Zcode and Xcode.", NSLocalizedRecoverySuggestionErrorKey,
                                                                                   nil]];
    }
    return nil;
  }  

  //////////
  errstr = nil;
  NSString *isaStr = [dict objectForKey:@"isa"];
  if(!isaStr)
    errstr = [NSString stringWithFormat:@"%@'s 'isa' is nil", key];
  else if (![isaStr isKindOfClass:[NSString class]])
    errstr = [NSString stringWithFormat:@"%@'s 'isa' is not a string", key];
  
  if(errstr)
  {
    NSLog(@"%@", errstr);
    if(error  && required)
    {
      *error = [NSError errorWithDomain:NSOSStatusErrorDomain
                                   code:0 // FIXME use correct key
                               userInfo:[NSDictionary dictionaryWithObjectsAndKeys:errstr, NSLocalizedDescriptionKey,
                                                                                   filename, NSFilePathErrorKey,
                                                                                   @"Check that project's project.pbxproj is generated by a supported version of Zcode and Xcode.", NSLocalizedRecoverySuggestionErrorKey,
                                                                                   nil]];
    }
    return nil;
  }  
  ////////////
  Class classFromIsa = objc_lookup_class([isaStr UTF8String]);
  if(!classFromIsa)
    errstr = [NSString stringWithFormat:@"Zcode's internal class '%@' does not exist", isaStr];
  if(errstr)
  {
    NSLog(@"%@", errstr);
    if(error  && required)
    {
      *error = [NSError errorWithDomain:NSOSStatusErrorDomain
                                   code:0 // FIXME use correct key
                               userInfo:[NSDictionary dictionaryWithObjectsAndKeys:errstr, NSLocalizedDescriptionKey,
                                                                                   filename, NSFilePathErrorKey,
                                                                                   @"Check that project's project.pbxproj is generated by a supported version of Zcode and Xcode.", NSLocalizedRecoverySuggestionErrorKey,
                                                                                   nil]];
    }
    return nil;
  }  
  
  
  //////////////
  id instanceFromIsa = [classFromIsa alloc];
  if(![instanceFromIsa respondsToSelector:@selector(initWithObjects:ownKey:ownerDocument:error:)])
    errstr = [NSString stringWithFormat:@"Zcode's internal class '%@' does not respond to initialization selector", isaStr];
  if(errstr)
  {
    NSLog(@"%@", errstr);
    if(error  && required)
    {
      *error = [NSError errorWithDomain:NSOSStatusErrorDomain
                                   code:0 // FIXME use correct key
                               userInfo:[NSDictionary dictionaryWithObjectsAndKeys:errstr, NSLocalizedDescriptionKey,
                                                                                   filename, NSFilePathErrorKey,
                                                                                   @"Check that project's project.pbxproj is generated by a supported version of Zcode and Xcode.", NSLocalizedRecoverySuggestionErrorKey,
                                                                                   nil]];
    }
    [instanceFromIsa release];
    return nil;
  }  
    
    
  return [instanceFromIsa initWithObjects:objects ownKey:key ownerDocument:self error:error];
  
}

#pragma mark -
#pragma mark Project-related commands
-(IBAction)build:(id)sender
{
  NSLog(@"build");
}

#pragma mark -
#pragma mark Toolbar delegate
- (NSToolbarItem*)toolbar: (NSToolbar*)toolbar
    itemForItemIdentifier: (NSString*)itemIdentifier
willBeInsertedIntoToolbar: (BOOL)flag
{
  NSToolbarItem* ti = [[NSToolbarItem alloc] initWithItemIdentifier:itemIdentifier];
  [ti setLabel:@"Build"];
  [ti setPaletteLabel:@"Build"];
  [ti setToolTip:@"Build"];
  [ti setTarget:self];
  [ti setAction:@selector(build:)];
  NSSize sz = {48,48};
  [ti setMinSize:sz];
  [ti setImage:[[[NSImage alloc] initWithContentsOfFile:@"/usr/share/icons/gnome/48x48/actions/system-run.png"] autorelease]];

  return ti;
}
// required method
- (NSArray*) toolbarAllowedItemIdentifiers: (NSToolbar*)toolbar
{
  return [NSArray arrayWithObjects:@"build", nil];

}
// required method
- (NSArray*) toolbarDefaultItemIdentifiers: (NSToolbar*)toolbar
{
  return [NSArray arrayWithObjects:@"build", nil];

}

#pragma mark -
#pragma mark Outline view

- (NSInteger)outlineView:(NSOutlineView *)outlineView numberOfChildrenOfItem:(id)item
{
  if(item == nil)
  {
    return [gafContainers count];
  }
  if([item respondsToSelector:@selector(numberOfChildrenForOutlineView:)])
  {
    return [item numberOfChildrenForOutlineView:outlineView];
  }
  return 0;
}
- (id)outlineView:(NSOutlineView *)outlineView objectValueForTableColumn:(NSTableColumn *)tableColumn byItem:(id)item
{
  return item;
}
- (BOOL)outlineView:(NSOutlineView *)outlineView isItemExpandable:(id)item
{
  if([item respondsToSelector:@selector(isExpandableForOutlineView:)])
  {
    return [item isExpandableForOutlineView:outlineView];
  }
  return NO;
}
- (id)outlineView:(NSOutlineView *)outlineView child:(NSInteger)index ofItem:(id)item
{
  if(item == nil)
  {
    return [gafContainers objectAtIndex:index];
  }
  if([item respondsToSelector:@selector(child:forOutlineView:)])
  {
    return [item child:index forOutlineView:outlineView];
  }
  return nil;
}
- (void)outlineView:(NSOutlineView *)outlineView setObjectValue:(id)object forTableColumn:(NSTableColumn *)tableColumn byItem:(id)item
{
  // 
}

@end
